function dat2niix(dicomDirectory, datDirectory, niftiDirectory, options)
%dat2niix - A function that generates multi-echo NIfTI files from raw image
%           data saved by WashU's NORDIC functor from the CMRR BOLD EPI.
%
%Usage: dat2niix(dicomDirectory, datDirectory, niftiDirectory)
%       dat2niix(dicomDirectory, datDirectory, niftiDirectory, options)
%
%dicomDirectory: The full path to a directory that contains the DICOM of
%                the first echo. If magnitude and phase data are saved,
%                each must be saved in individual and separate directories.
%
%datDirectory: The full path to a directory of all the raw image (*.dat)
%              files generated by the NORDIC functor. These dat files need
%              not be separated into different directories for each series
%              or for magnitude & phase data. Everything can exist in one
%              location, which is how they are saved on the scanner.
%
%niftiDirectory: The full path to the directory that will contain the new
%                NIfTI files. It is recomended that this folder be empty to
%                avoid confusion, but that is not required.
%
%Options: Verbose = true/(false) - verbose output to the command line
%         highPrecision = true/(false) - TE recorded in headers with 
%                         microsecond precision when set to true, otherwise
%                         the TE is recorded with more common tenth of a
%                         millisecond precision
%         reportTime = true/(false) - report the total time spent
%                                     processing the job
% 
% This function works in conjunction with both the CMRR multiband BOLD EPI 
% sequence and the WashU NORDIC recon functor to produce multi-echo, 
% compressed NIfTIs assembled from the raw image data saved on the scanner
% and header information gathered from both the DICOM of the first echo and
% the NIfTI generated by dcm2niix.
%
% This solution is meant to avoid resource spikes on the scanner host due
% to what is suspected to be lack of full support of multi-echo images from
% the CMRR BOLD EPI sequence. The NORDIC functor writes only the first echo
% to the host's database and routes the raw images data to a temporary
% location on the scanner's local drive. The raw images do not have any
% metadata associated with them, so dcm2niix is used to generate the first
% echo's header from the DICOM. This function uses the DICOM and the NIfTI
% from dcm2niix to assemble NIfTIs of all echos, one file per echo. 
%
% The multi-echo NIfTI headers contain the correct TE for their respecitve
% data and the slice timing parameters for all bu the first echo have their
% respective TEs added to them. It is possible to force maximum precision
% recording of the TEs with the highPrecision logical argument.
%
% Two dependencies exist for this function. The package dcm2niix is
% maintained and distributed at <a href="matlab:web('https://github.com/rordenlab/dcm2niix')">Chris Rorden's GitHub.</a>
% The M-file parseMrProt.m is maintained and distributed at 
% <a href="matlab:web('https://github.com/jeffreyluci/Siemens-Tools/tree/main/parseMrProt')">Jeff Luci's GitHub.</a>
% All software called by or otherwise used by this M-file is subject to the
% license and citation requirements described on their GitHub pages.
%
%The NORDIC reconstruction functor (pipeline) is available at 
% <a href="matlab:web('https://webclient.us.api.teamplay.siemens-healthineers.com/c2p')">The Siemens Teamplay C2P Exchange.</a>
%
% This function is maintained <a href="matlab:web('https://github.com/jeffreyluci/Siemens-Tools/tree/main/dat2niix')">at this URL.</a>:
% Version: 20240201

% Author: Jeffrey Luci, jeffrey.luci@rutgers.edu
% https://github.com/jeffreyluci/Siemens-Tools/tree/main/dat2niix
% VERSION HISTORY:
% 20240201: Initial Release.
% 20240202: Added timed option and numerous comment improvements.


arguments
    dicomDirectory char
    datDirectory   char
    niftiDirectory char
    options.Verbose       (1,1) logical = false
    options.highPrecision (1,1) logical = false
    options.reportTime    (1,1) logical = false
end

if options.Verbose
    tic;
end

if options.highPrecision
    TEPrecision = '%0.3f';
else
    TEPrecision = '%0.1f';
end

%Check to ensure prerequisites are installed
checkDcm2niixVersion(options);
mrProtExists = exist('parseMrProt.m', 'file');
if mrProtExists ~= 2
    error('parseMrProt.m is not found in the path. See help for instructions.');
end


%Format directory names
if ~strcmp(niftiDirectory(end), filesep)
    niftiDirectory = sprintf('%s%c', niftiDirectory, filesep);
end
if ~strcmp(datDirectory(end), filesep)
    datDirectory = sprintf('%s%c', datDirectory, filesep);
end

%Check to ensure source and target directories exist
if ~exist(dicomDirectory, "dir")
    error('The directory %s is not found.', dicomDirectory);
elseif options.Verbose
    disp([dicomDirectory ' found.']);
end
if ~exist(datDirectory, "dir")
    error('The directory %s is not found.', datDirectory);
elseif options.Verbose
    disp([datDirectory ' found.']);
end
if ~exist(niftiDirectory, "dir")
    error('The directory %s is not found.', niftiDirectory);
elseif options.Verbose
    disp([niftiDirectory ' found.']);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 1 - Parse the DICOMs and get the information %
%          needed from the headers                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

d=dir(dicomDirectory);

%Assume all files in dicomDirectory are DICOMs, and initialize 
%the workList struct explicitly to ensure maximum efficency
workList(numel(dicomDirectory)-1).dicomName    = [];
workList(numel(dicomDirectory)-1).imgType      = [];
workList(numel(dicomDirectory)-1).repNum       = [];
workList(numel(dicomDirectory)-1).datFile      = [];
workList(numel(dicomDirectory)-1).seriesUID    = [];
workList(numel(dicomDirectory)-1).datFileMatch = [];


curDicom = 1;
for ii = 3:numel(d)
    curFile = fullfile(dicomDirectory, d(ii).name);
    if isdicom(curFile)
        workList(curDicom).dicomName = curFile;
        if options.Verbose
            disp(['Parsing: ' workList(curDicom).dicomName]);
        end
        hdr = dicominfo(workList(curDicom).dicomName);
        if contains(hdr.SeriesDescription, 'BOLD_NORDIC') %only select NORDIC DICOMs
            if strcmp(hdr.ComplexImageComponent, 'MAGNITUDE')
                workList(curDicom).imgType = 'mag';
            elseif strcmp(hdr.ComplexImageComponent, 'PHASE')
                workList(curDicom).imgType = 'phs';
            else
                error('Unknown data type in %s.', workList(curDicom).dicomName);
            end
            workList(curDicom).repNum = hdr.InstanceNumber;
            workList(curDicom).datFile = 'pending';
            workList(curDicom).seriesUID = trimUID(hdr.SeriesInstanceUID);
            if curDicom == 1
                mrProt = parseMrProt(hdr);
            end
            curDicom = curDicom + 1;
        end
    end
end

%Warn user if DICOMs are not XA
if options.Verbose
    disp('Checking DICOM version for compatibility.');
end
if ~contains(hdr.ImplementationVersionName, 'XA')
    warning(['The DICOMs do not appear to be acquired using at least', newline, ...
            'the Syngo XA-line platform. This software was written', newline, ...
            'for XA-acquired enhanced DICOMs. Other verisons might', newline, ...
            'work, but it is not guaranteed, and you should take extra', newline, ...
            'precautions to ensure the results are as expected.']);
end


%Clean up workList by making sure the number of elements 
%is consistent with the number of DICOMs found. This is necessary since we
%assume above that all files in dicomDirectory are DICOMs. It that's not
%true, then the size of workList will be too long.
if numel(workList) > curDicom-1
    if options.Verbose
        disp(['Trimming of worklist is necessary.', newline, ...
              'This probably means there were non-DICOM files', newline, ...
              'in the DICOM directory. This should not matter.'])
    end
    workList(curDicom:end) = [];
end

numEchos  = mrProt.lContrasts;
TE        = mrProt.alTE(1:numEchos);
patientID = hdr.PatientID;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 2 - Match the DICOMs with the associated dat %
%          files - both mag and phs as appropriate  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for ii = 1:numel(workList)
    baseName = sprintf('%s%s_%s_', datDirectory, patientID);
    if strcmp(workList(ii).imgType, 'mag')
        workList(ii).datFile = sprintf('%s%s_Mag_%04d.dat', baseName, ...
                                               workList(ii).seriesUID, ...
                                               workList(ii).repNum);
        if options.Verbose
            disp('DICOMs identified as MAGNITUDE images.')
        end
    elseif strcmp(workList(ii).imgType, 'phs')
        workList(ii).datFile = sprintf('%s%s_Phs_%04d.dat', baseName, ...
                                               workList(ii).seriesUID, ...
                                               workList(ii).repNum);
        if options.Verbose
            disp('DICOMs identified as PHASE images.')
        end
    else
        error('Unknown Image data type.');
    end

    if exist(workList(ii).datFile, 'file')
        workList(ii).datFileMatch = true;
        if options.Verbose
            disp(['DICOM matched with ', workList(ii).datFile])
        end
    else
        workList(ii).datFileMatch = false;
        if options.Verbose
            disp(['Expected ', workList(ii).datFile, ' as dat file, but not found.'])
        end
    end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 3 - Call dcm2niix to generate the NIfTI files %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

if options.Verbose
    cmdString = ['dcm2niix -v y -z y -f %j -o ', niftiDirectory, ' ', dicomDirectory];
else
    cmdString = ['dcm2niix -z y -f %j -o ', niftiDirectory, ' ', dicomDirectory];
end
[~, STDOUT] = system(cmdString);
if options.Verbose
    disp(STDOUT)
end
if strcmp(workList(1).imgType, 'mag')
    niftiBaseName = hdr.SeriesInstanceUID;
else
    niftiBaseName = [hdr.SeriesInstanceUID, '_ph'];
end
niftiTargetName = [niftiBaseName, '.nii.gz'];
if ~exist(fullfile(niftiDirectory,  niftiTargetName), 'file')
    error('dcm2niix failed to create the expected NIfTI file. Check the target directory.');
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 4 - Strip the header from the generated NIfTI   %
%          and use it to construct new NIfTI headers   %
%          for each echo of the data.                  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

niftiHdr = niftiinfo(fullfile(niftiDirectory, niftiTargetName));
numPointsRead  = niftiHdr.ImageSize(1);
numPointsPhase = niftiHdr.ImageSize(2);
numSlices      = niftiHdr.ImageSize(3);
numReps        = niftiHdr.ImageSize(4);

%Prepare to edit the TE listed in the parent and raw descriptions
niftiDescription = split(niftiHdr.Description, ';');
TELocation = find(contains(niftiDescription, 'TE'));
niftiTE = split(niftiDescription{TELocation}, '=');

%Construct headers with correct echo times for all echos
%Precision of TE reported to a tenth of a millisecond by default,
%and to a microseond if requested in the options
for ii = 2:numEchos
    niftiHdr(ii) = niftiHdr(1);
    curTE = sprintf(TEPrecision, TE(ii)/1000);
    niftiTE{2} = curTE;
    TELine = char(join(niftiTE, '='));
    if options.Verbose
        disp(['Echo ', num2str(ii), ': ', TELine]);
    end
    niftiDescription{TELocation} = TELine;
    niftiHdr(ii).Description = char(join(niftiDescription, ';'));
    niftiHdr(ii).raw.descrip = niftiHdr(ii).Description;
end

%Read in raw data and reshape it to NIfTI dimensions
[~,repetitionOrder] = sort([workList.repNum]);
if options.Verbose && ~isequal(repetitionOrder, [workList.repNum])
    disp(['Repetitions are not written to DICOMs in chronological order.', newline, ...
          'It is HIGHLY recommended you check to ensure the sorted', newline, ...
          'images are in the correct order.', newline]);
end
rawIM = uint16(zeros(numPointsRead, numPointsPhase, numSlices, numEchos, numReps));

 for ii = 1:numel(workList)
    fid = fopen(workList(repetitionOrder(ii)).datFile, 'rb');
    rawStream = fread(fid, inf, 'uint16');
    fclose(fid);
    rawStream = reshape(rawStream,[numPointsRead, numPointsPhase, numSlices, numEchos]);
    rawStream = permute(rawStream,[2 1 3 4]);
    %Assume interleaved slice ordering, but in the future other ordering 
    %options might be enabled, in which case the slice order should be 
    %determined from the DICOM header
    [~,sliceOrder] = sort([2:2:numSlices 1:2:numSlices-1]);
    rawStream = rawStream(:,:,sliceOrder,:);
    rawIM(:,:,:,:,ii) = rawStream;
 end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 5 - Write out new NIfTI files with modified headers %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

niftiNameBase = sprintf('%s_%s_%03d_', hdr.PatientID, ...
                                       replace(hdr.SeriesDescription, '_Pha', ''), ...
                                       hdr.SeriesNumber);
for ii = 1:numEchos
    if strcmp(workList(1).imgType, 'mag')
        nameAppendix = sprintf('_mag_e%d', ii);
    else
        nameAppendix = sprintf('_phs_e%d', ii);
    end
    curName = [niftiNameBase, nameAppendix];
    if options.Verbose
        disp(['Writing: ', curName]);
    end
    niftiwrite(squeeze(rawIM(:,:,:,ii,:)), fullfile(niftiDirectory, curName), ...
                                           niftiHdr(ii), 'Compressed', true);
end

%Clean up temporary NIfTI file from dcm2niix to avoid confusion
if options.Verbose
    disp('Removing temporary NIfTI file generated by dcm2niix.');
end
delete(fullfile(niftiDirectory,  niftiTargetName));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Step 6 - Write new json files with correct TE and slice  %
%          timing for each echo consistent with the NIfTI  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

jsonFilename = fullfile(niftiDirectory, [niftiBaseName, '.json']);
if options.Verbose
    disp(['Reading json file: ', jsonFilename]);
end
fid = fopen(jsonFilename, 'rt');
jsonContents = fread(fid, inf, 'uint8=>char')';
fclose(fid);
jsonStruct = jsondecode(jsonContents);

for ii = 1:numEchos
    jsonStruct(ii) = jsonStruct(1);
    jsonStruct(ii).EchoTime = str2double(sprintf('%0.4f', TE(ii)/10e6));
    jsonStruct(ii).SliceTiming = jsonStruct(1).SliceTiming + TE(ii)/10e6;

    curJsonTxt = jsonencode(jsonStruct(ii), PrettyPrint=true);
    if strcmp(workList(1).imgType, 'mag')
        nameAppendix = sprintf('_mag_e%d.json', ii);
    else
        nameAppendix = sprintf('_phs_e%d.json', ii);
    end
    curName = fullfile(niftiDirectory, [niftiNameBase, nameAppendix]);
    if options.Verbose
        disp(['Writing new json file: ', curName]);
    end
    fid = fopen(curName, 'wt');
    fwrite(fid, curJsonTxt, 'uint8');
    fclose(fid);
end

%Clean up temporary NIfTI file from dcm2niix to avoid confusion
if options.Verbose
    disp('Removing temporary json file generated by dcm2niix.');
end
delete(jsonFilename);

%Report time spent
timeSpent = num2str(toc);
if options.Verbose || options.reportTime
    disp(['Total time spent in process: ', timeSpent, ' sec.']);
end


end



function dateOfVersion = checkDcm2niixVersion(options)
        [STDERR,STDOUT] = system('dcm2niix -h');
        if STDERR ~= 0 
            error('Could not verify dcm2niix installation.');
        end
        if numel(STDOUT) < 5
            error('dcm2niix is not found on the path. See help for instructions.');
        end
        if(options.Verbose)
            disp(STDOUT);
        end
        STDOUT = split(STDOUT, ' ');
        verStrLocation = find(contains(STDOUT, 'version'))+1;
        versionString = STDOUT{verStrLocation(1)};
        if numel(versionString) < 13
            error('dcm2niix is not found on the path. See help for instructions.');
        end
        try
        versionMatrix = sscanf(versionString, 'v%d.%d.%d');
        dateOfVersion = datetime(num2str(versionMatrix(3)), 'InputFormat', 'yyyyMMdd');
        catch
            error('dcm2niix is not found on the path. See help for instructions.');
        end
        if options.Verbose
            disp(['dcm2niix found, version dated: ', char(dateOfVersion)]);
        end

    end


    function newUID = trimUID(instanceUID)
    newUID = instanceUID;

        while strcmp(newUID(end-1:end), '.0')
            newUID = newUID(1:end-2);
        end
    end
